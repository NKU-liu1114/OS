## <center>2113946刘国民Lab5实验报告</center>

### 练习1: 加载应用程序并执行（需要编码）
do_execv 函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

代码如下：
```c++
    tf->gpr.sp = USTACKTOP;
    tf->epc = elf->e_entry;
    tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```
**设计实现过程：**
第六步主要完成中断帧的设置，即能从内核态正确返回用户模式，并从应用程序起始地址开始执行。这需要对 tf 结构体进行设置，具体步骤如下：
1. 设置tf的gpr.sp即存储栈顶指针为用户栈的顶部地址（ USTACKTOP ），以便在用户程序运行时可以正确地访问栈。
2. 设置tf的epc为程序的入口点，即 elf->e_entry，异常或中断恢复时，pc根据epc的值跳转到程序入口点，用户程序则开始正常执行。
3. 设置tf的status即存储处理器的状态信息。其中用到了两个状态位SSTATUS的SPP和SPIE。

> SPP 用于表示处理器在发生异常或中断之前的特权级别。0表示用户级别，1表示特权级别。调用 sys_exec 之后， 我们在 trap 返回的时候调用了 sret 指令。sret指令会根据SPP的值回到中断前的状态。为了最终通过 sret 返回用户态，所以SPP应该为0。
> SPIE 用于表示处理器在发生异常或中断之前的中断使能状态。0表示中断被禁用，1表示中断被启用。为了保证用户态能够正常触发中断，因此应该启用中断，即SPIE应该为1。


**请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。**

流程如下：
1. 将ELF文件加载到内存中。具体由do_execve实现，需要将当前进程使用的资源清空或删除，包括页表以及内存映射，释放mm结构体等。
2. 加载应用程序，包括读取ELF格式的文件，申请内存空间，建立用户态虚存空间。主要由load_icode实现。需要创建结构体来管理内存，创建页表来进行映射，加载ELF文件头，建立内存映射、初始化用户栈以及顶级页表等等。（即load_icode 1-6步的内容）
3. 用户态进程被选择执行，本质上是通过一个中断处理来完成。在这个过程中，上下文结构体的epc和status被重新设置，即epc设置为了用户态进程的入口，status设置为了用户态。返回上下文的时候根据相应信息即可正确开始执行用户程序。即触发中断后“欺骗”了处理器，没有再回到原来的执行点，而是重新设置了权限和pc。而前面的步骤则是设置程序执行需要的内存资源以及栈空间等等。


### 练习2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。

需要补充的代码如下：
```c++
    uintptr_t src_kvaddr = page2kva(page);
    uintptr_t dst_kvaddr = page2kva(npage);
    memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
    ret = page_insert(to, npage, start, perm);
    assert(ret == 0);
```
1. 首先通过刚开始获取的page即源page通过宏page2kva转换为源虚拟内存地址。
2. 同样的将要复制过去的n个page转换为目的虚拟内存地址。
3. 通过memcpy将虚拟地址进行复制，复制其内容。
4. 最后我们再使用前面的参数（to是目标进程的页目录地址，npage是页，start是起始地址，perm是提取出的页目录项ptep中的PTE_USER即用户级别权限相关的位）调用page_insert函数

### 练习3：练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

1. fork:
用户态：父进程调用 fork() 系统调用。
内核态：内核复制父进程的所有资源（内存、文件描述符等），创建一个新的子进程。
用户态：子进程从 fork 调用返回，得到一个新的进程ID（PID），父进程也从 fork 调用返
回，得到子进程的PID。
2. exec:
用户态：进程调用 exec 系统调用，加载并执行新的程序。
内核态：内核加载新程序的代码和数据，并进行一些必要的初始化。
用户态：新程序开始执行，原来的程序替换为新程序。
3. wait:
用户态：父进程调用 wait 或 waitpid 系统调用等待子进程的退出。
内核态：如果子进程已经退出，内核返回子进程的退出状态给父进程；如果子进程尚未退出，
父进程被阻塞，等待子进程退出。
用户态：父进程得到子进程的退出状态，可以进行相应的处理。
4. exit:
用户态：进程调用 exit 系统调用，通知内核准备退出。
内核态：内核清理进程资源，包括释放内存、关闭文件等。
用户态：进程退出，返回到父进程。
