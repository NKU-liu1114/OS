### 实验准备

在lab1可以运行的前提下，确保makefile里面的qemu可以工作，如果makefile被修改错了，粘贴原始lab2里面的makefile进行覆盖。

中间可能提示fatal error: -fuse-linker-plugin, but liblto_plugin.so not found，需要在工具链目录下找到 liblto_plugin.so.0.0.0 复制成一份 liblto_plugin.so 顺利解决

开始实验：修改makefile里面的opensbi的版本为正确版本,修改bios对应文件为GitHub下载下来的文件:
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013183323996.png" alt="image-20231013183323996" style="zoom:50%;" />

此时可以make qemu应该可以看到大量的kkkk
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013183845696.png" alt="image-20231013183845696" style="zoom:50%;" />
为什么出现kkk呢，因为debug的panic.c里面故意设置了一个for循环输出k，把它注释掉就行

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013184347083.png" alt="image-20231013184347083" style="zoom: 33%;" />

此时再make qemu,可以看到opensbi被启动了：
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013184824216.png" alt="image-20231013184824216" style="zoom:50%;" />

然后了解一下库函数list后面有用
![image-20231013213100715](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013213100715.png)

list是一个双向链表，可以被struct list_entry理解为node,又把struct list_entry简写为list_entry_t

其中这里的add很迷，__list_add是把elm插入节点prev和next之间。list_add_after是把elm插入listelm和listelm->next之间，和list_add一模一样。而list_add_before是把elm插入listelm和listelm->pre之间。init是让前后指针指向自己。

__list_del是让pre和next指向彼此，list_del是删掉一个元素，list_del_init是删掉元素，让它自己指向自己，list_empty通过是否指向自己判断是不是空的，list_prev和list_next是获取list前后元素的接口。
为了测试list，这里写了一个testlist放在test文件夹里面
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013214915889.png" alt="image-20231013214915889" style="zoom:50%;" />

可以实现基本的插入删除

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231013214948482.png" alt="image-20231013214948482" style="zoom:50%;" />





#### 练习1：理解first-fit 连续物理内存分配算法（思考题）

first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：

你的first fit算法是否有进一步的改进空间？

##### 对于default_init的理解

首先来分析kern/mm/default_pmm.c,首先要理解单词的意思，kern:kernel

mm: **memory management**内存管理

pmm:**physical memory management**物理内存管理，区别于虚拟内存管理vmm

然后要理解什么是free_area_t【为了理解方便，我们可以把结构体理解为一个类】
![image-20231014152212467](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014152212467.png)
free_area_t可以理解为一个类，其中有两个属性，首先是一个ListNode ,叫做free_list,然后是一个整数，表明freelist里面的空闲页面数量。free_area_t free_area相当于新建了一个对象，而这个对象的属性值可以被free_list，nr_free快速获取

![image-20231014152304802](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014152304802.png)

初始化操作，初始化了这个Node节点free_list,调用的是list.h里面的初始化函数，然后把nr_free计数为0

![image-20231014153009834](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014153009834.png)

此时表示的状态是：没有可用区块，freelist是空列表：

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014175543071.png" alt="image-20231014175543071" style="zoom: 67%;" />

#####  对于default_init_memmap的理解

然后要理解default_init_memmap【初始化内存映射】函数，需要理解：
assert是一个宏，如果断言失败，终止执行
还要理解page是什么，page来自于memlayout.h【内存结构】

![image-20231014153948267](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014153948267.png)
通常来说：pte_t页表项（Page Table Entry, PTE），页目录项（Page Directory Entry, PDE)，ref： 页框被进程等引用的次数，flags，用比特位表示页框的状态，如被分配与否。property：空闲块的数量。page_link对应着freelist

![image-20231014170602961](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014170602961.png)
在初始化内存分配时，第一步操作的效果如下

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014170538481.png" alt="image-20231014170538481" style="zoom: 67%;" />

而下一步的作用是，在freelist里面，将新页面块插入正确位置
![image-20231014171601767](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014171601767.png)


假设我们有以下 `free_list` （假设使用基地址表示）:

![image-20231014171426357](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014171426357.png)

如果我们要插入一个基地址为 `250` 的新页面块，则新页面块应插入 `100` 和 `300` 之间：

![image-20231014171443508](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014171443508.png)

此时，当我们遍历到基址为 `100` 的页面块时，下一个页面块是 `300`，`250 < 300(page)`，所以我们使用 `list_add_before` 将新页面块插入 `300`(page) 之前。

现在，考虑我们要插入一个基址为 `600` 的新页面块，这个页面块应该插入 `500` 后面，即链表的末尾：

![image-20231014171454646](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014171454646.png)

当我们遍历到 `500` 时，它的下一个链表入口是 `free_list` 的头部，所以我们知道已经到达链表的末尾。这时，我们使用 `list_add` 将新页面块添加到 `500` 之后。

##### 对于default_alloc_pages的理解

![image-20231014172730266](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014172730266.png)

首先确保请求的页数（`n`）大于0，并且空闲列表中有足够的页来满足请求。如果没有，函数直接返回NULL。

迭代freelist，搜索一个具有足够连续空闲页（`property >= n`）的页块。
![image-20231014172936868](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014172936868.png)

- 如果找到了合适的页块，先从链表中移除这个页块的描述符。
- 如果这个页块的大小（`property`）比请求的页数更大，那么将多余的页块重新添加回freelist。
  **返回分配的页块**: 返回找到的页块的描述符，如果没有找到则返回NULL。

![image-20231014181300483](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014181300483.png)

我们有大小为2, 4, 和 1的三个空闲块。如果我们需要3个页，则`page`将指向大小为4的块，因为这是第一个满足条件的块。

##### 对于default_free_pages的理解：

这个操作是将（之前使用过的）页面清空（可以重新使用），也叫做free，而页面可以通过设置property字段为n，flags=0,ref=0来表示清空。

![image-20231014174050381](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014174050381.png)

遍历要释放的页块，确保每一页都可以被释放（即，它们既不是预留的也不是已标记为属性的）。然后，重置每页的标志和引用计数。

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014174130871.png" alt="image-20231014174130871" style="zoom: 67%;" />

仅仅是释放页面还不够，释放掉的页面还应该被freelist管理，因此进行下面的操作：
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014175020277.png" alt="image-20231014175020277" style="zoom:67%;" />

**如果free_list是空的**: 如果没有其他空闲的页块（即free_list是空的），那么新释放的页块就会被添加到free_list中。

之前
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014175543071.png" alt="image-20231014175543071" style="zoom: 67%;" />
之后

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014175840516.png" alt="image-20231014175840516" style="zoom:67%;" />

**如果free_list不是空的**: 在这种情况下，我们需要找到在物理地址排序中正确的位置来插入新释放的页块。因此，我们会遍历free_list，比较每个存在的页块与base的物理地址。如果base的地址小于当前页块的地址，我们就在当前页块之前插入base。如果我们遍历到了free_list的末尾，那么我们将base添加到最后。(假设Base的地址小于Page A)
<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014175751012.png" alt="image-20231014175751012" style="zoom:67%;" />

仅仅更新free list也是不够的，还需要考虑碎片的合并
![image-20231014180153229](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014180153229.png)

1. 找到base的前一个列表条目：`list_prev(&(base->page_link))` 返回base前的页块。
2. 检查前一个条目是否是free_list的头：如果`le`不是`free_list`的头，那么它代表了一个有效的空闲页块。
3. 确定前一个页块的结束是否与base的开始紧邻：这通过比较`p + p->property`（前一个页块的结束）与base来实现。如果它们是紧邻的，那么它们可以合并。
4. 合并页块：通过增加`p`的`property`（即它现在覆盖的页数）来实现，并清除base的`property`标志。因为base现在已经成为`p`的一部分，所以我们从`free_list`中删除base。
5. 更新base指针：将base设置为p，因为base现在指向合并后的更大的空闲块。

![image-20231014180206900](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014180206900.png)

![image-20231014180935223](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014180935223.png)
和之前的代码非常相似，只不过现在它是检查`base`后面的页块，而不是前面的页块，以查看是否可以进行合并。

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20231014180949086.png" alt="image-20231014180949086" style="zoom:67%;" />

##### 优化方案

**伙伴系统（Buddy System）**: 它将内存分成大小为2的幂的块，并尝试满足内存请求的最接近的块大小。好处是减少内存碎片。

**延迟合并（Deferred Coalescing）**: 而不是立即合并空闲块，可以延迟合并直到有需求或系统处于低负载状态。

**内存压缩**: 在系统内存紧张时，可以考虑将内存中的内容紧凑排列，释放连续的空间。


#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）

在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：

- 你的 Best-Fit 算法是否有进一步的改进空间？

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）

  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。