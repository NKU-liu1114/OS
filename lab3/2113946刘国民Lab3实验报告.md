## <center>**Lab3实验报告**</center>


### 变量/宏/函数定义说明

* sv39中采用的是三级页表，从高到低三级页表的页码分别称作PDX1, PDX0和PTX(Page Table Index)。

* 39位的虚拟地址，`PDX1(9)|PDX0(9)|PTX(9)|PGOFF(12)`，相关的宏定义通过位运算实现

* `PPN=PDX1(9)|PDX0(9)|PTX(9)`

* 虚拟地址通过`PGADDR(PDX(la), PTX(la), PGOFF(la))`得到

* Sv39的物理地址：`PPN2(26)|PPN1(9)|PPN0(9)|PGOFF(12)`

* Sv39的页表项：`PPN2(26) | PPN1(9) | PPN0(9) |Reserved(2)|D|A|G|U|X|W|R|V|`



#### 练习2：深入理解不同分页模式的工作原理（思考题）
首先，我们对get_pte()函数做一个解析。
  ```c++
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {}
 ```
 参数部分：
 1. pgdir:内核中PDT的虚拟地址
 2. la:需要被映射的虚拟地址
 3. create:是否准许分配一个页面
 4. 返回虚拟地址的页表项


 ```C++
 // 把虚拟地址左移30位得到PTX1的索引，pgdir为页表基址，&pgdir[PDX1(la)]则为页表中第PDX1项的起始地址，让pdep1指向该页表项
    pde_t *pdep1 = &pgdir[PDX1(la)];            // 找到对应的Giga Page
    if (!(*pdep1 & PTE_V)) {                    // 如果下一级页表不存在，那就给它分配一页，创造新页表
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) { // create为1并且成功找到多的1个物理页才分配
            return NULL;
        }
        set_page_ref(page, 1);                          // 增加对物理页面page的引用数
        uintptr_t pa = page2pa(page);                   // page2pa 将一个页转换成这个页的物理地址
        memset(KADDR(pa), 0, PGSIZE);                   // 把物理地址pa映射到虚拟地址中，之后的一页内容全部置0
        // 不管页表怎么构造，我们确保物理地址和虚拟地址的偏移量始终相同，那么就可以用这种方式完成对物理内存的访问。
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
 ```
第一段是根据`la`前9位的索引，让`pdep1`指向`PTX1`顶级页表的第`PDX1(la)`项，如果该项不存在并且设置为可以被分配，那就分配一个物理页并且增加1次引用。
对于`page2pa`函数，在此一并分析。函数定义如下：
```C++
static inline ppn_t page2ppn(struct Page *page) { return page - pages + nbase; } 
// 页块数组中，页块的指针-页块数组的起始地址为页块编号，再把编号加上基准页数即为整个物理内存分页后的页编号
// 物理页码（PPN）只是一个数字，它表示页在物理内存中的索引或顺序位置。

static inline uintptr_t page2pa(struct Page *page) {
    return page2ppn(page) << PGSHIFT;
    // 物理页码左移12位后，就得到了以改页码
}
```
`page2pa`的功能是把页块结构体指针`page`映射到对应的物理页的起始地址上。其中调用了`page2ppn`这个函数。由于在Lab2中，在内核代码结束的内存空间里，我们用一个页块数组来存储从物理地址`0x80000000-0x88000000`的地址空间按照4KB分页后的页数。`pages`是该数组的起始地址，`page-pages`即为数组内的偏移，加上`nbase`即为对整个物理内存分页后的物理页码，左移12位号即为该页的起始物理地址。

继续分析`get_pte()`,`pa`中存储`page`页的物理地址，之后调用`memset()`将pa对应的虚拟地址上的一页内容全置为0，之后填入页表项内容（将物理地址和虚拟地址建立映射）。对于第二段，跟第一段的逻辑类似，来构造下一级页表`PDX0`的页表项，根据构造号的页表项再来索引第三级页表`PTX`，并最终返回`PTX`页表项的虚拟地址，在此不再赘述。

思考题：

 - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 
从上面的分析中可以看到，在 `get_pte()` 函数中，两段形式类似的代码实际上对应了 `sv39` 页表模式中的两级页表访问。第一段代码PDX1中，根据la的前9位索引导到页表项，访问或分配`PDX0`的页表项。在此过程中，如果页表项不存在，那么需要一个物理页面来存放下一级页表，所以需要分配一个物理页并将其映射到对应的物理地址上，最终把这个物理地址存到页表项中；第二段代码访问或分配了`PTX`的页表项，进行的操作类似。两段代码看起来相似，因为它们执行的是类似的操作，但在不同级别的页表上。因为是从顶级页表开始，`get_pte()` 只需处理两级，并向下查找直到找到或创建所需的页表项。这种模式是多级页表系统的一种常见模式，无论是采用二级页表的`sv32`、采用三级页表的`sv39`、还是采用四级页表的`sv48`，都遵循相似的逻辑，只是层数和索引方式有所不同。

 - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？
 
 我认为这种写法没问题，也没有必要将两个操作分开。理由如下：
 
 - 简化代码。只需要调用一个函数，使得代码更加简洁。同时find和alloc两个操作都需要对PDX0和PDX1进行索引，拆开写会使得代码冗余，还需要增加新的函数参数和返回值，不利于维护。
 - 保持一致性。不单独提供alloc的函数接口，将查找和分配页表项的操作原子化，避免在其他代码中错误地调用了分配的函数，减少错误。