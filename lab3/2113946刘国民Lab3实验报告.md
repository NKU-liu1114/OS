## <center>**Lab3实验报告**</center>


### 变量/宏/函数定义说明

* sv39中采用的是三级页表，从高到低三级页表的页码分别称作PDX1, PDX0和PTX(Page Table Index)。

* 39位的虚拟地址，`PDX1(9)|PDX0(9)|PTX(9)|PGOFF(12)`，相关的宏定义通过位运算实现

* `PPN=PDX1(9)|PDX0(9)|PTX(9)`

* 虚拟地址通过`PGADDR(PDX(la), PTX(la), PGOFF(la))`得到

* Sv39的物理地址：`PPN2(26)|PPN1(9)|PPN0(9)|PGOFF(12)`

* Sv39的页表项：`PPN2(26) | PPN1(9) | PPN0(9) |Reserved(2)|D|A|G|U|X|W|R|V|`

* 连续虚拟内存区域：描述一段从vm_start到vm_end的连续虚拟内存。通过包含一个list_entry_t成员，把同一个页表对应的多个vma_struct结构体串成一个链表，在链表里把它们按照区间的起始点进行排序
```C++
struct vma_struct {
    // 关联的上层内存管理器
    struct mm_struct *vm_mm; 
    // 描述的虚拟内存的起始地址
    uintptr_t vm_start;      
    // 描述的虚拟内存的截止地址
    uintptr_t vm_end;        
    // 当前虚拟内存块的属性flags（读/写/可执行）
    uint_t vm_flags;        
    // 连续虚拟内存块链表节点 (mm_struct->mmap_list)
    list_entry_t list_link;  // 用于串成链表
};
```






* 内存管理结构体：一个总的内存管理器，统一管理虚拟内存以及物理内存。每个页表可能包含多个vma_struct, 也就是多个访问权限可能不同的，不相交的连续地址区间。用mm_struct结构体把一个页表对应的信息组合起来，包括vma_struct链表的首指针，对应的页表在内存里的指针，vma_struct链表的元素个数。
```C++
struct mm_struct {
    // 连续虚拟内存块链表 (内部节点虚拟内存块的起始、截止地址必须全局有序，且不能出现重叠)
    list_entry_t mmap_list;
    // 当前访问的mmap_list链表中的vma块(由于局部性原理，之前访问过的vma有更大可能会在后
    // 续继续访问，该缓存可以减少从mmap_list中进行遍历查找的次数，提高效率)        
    struct vma_struct *mmap_cache; 
    // 当前mm_struct关联的一级页表的指针
    pde_t *pgdir;                  
    // 当前mm_struct->mmap_list中vma块的数量
    int map_count;                 
    // 用于虚拟内存置换算法的属性，使用void*指针做到通用
    // lab中默认的swap_fifo替换算法中，将其做为了一个先进先出链表队列)
    void *sm_priv;                 
};
```

do_fault函数处理逻辑：
do_pgfault除了接受前面提到的中断错误号和引起错误的线性地址，还接受了当前进程的mm_struct结构，用以访问当前进程的页表。do_pgfault对错误码进行了处理，判断其究竟是否是因为缺页造成的页访问异常；还是因为非法的虚拟地址访问、特权级的越级内存访问等错误引发的页异常，如果是后者就应该报错或者让进程直接奔溃掉。

　　如果发现访问的是一个合法的虚拟地址，则会进一步找到引起异常的线性地址所对应的二级页表项，判断其是真的不存在(pte中的每一位都是0)还是之前被暂时交换到了磁盘上(仅仅是P位为0)。

　　如果是真的不存在，则需要立即为其分配一个初始化后全新的物理页，并建立映射虚实关系。

　　如果是被暂时交换到了磁盘中，则需要将交换扇区中的数据重新读出并覆盖所分配到的物理页。

　　页异常中断属于异常中断的一种，当中断服务例程返回后，会重新执行引起页异常的那条指令，如果do_pafault实现正确，那么此时将能够正确的访问到虚拟地址对应的物理页，程序能正常的往下继续执行。

#### 练习2：深入理解不同分页模式的工作原理（思考题）
首先，我们对get_pte()函数做一个解析。
  ```c++
pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create) {}
 ```
 参数部分：
 1. pgdir:内核中PDT的虚拟地址
 2. la:需要被映射的虚拟地址
 3. create:是否准许分配一个页面
 4. 返回虚拟地址的页表项


 ```C++
 // 把虚拟地址左移30位得到PTX1的索引，pgdir为页表基址，&pgdir[PDX1(la)]则为页表中第PDX1项的起始地址，让pdep1指向该页表项
    pde_t *pdep1 = &pgdir[PDX1(la)];            // 找到对应的Giga Page
    if (!(*pdep1 & PTE_V)) {                    // 如果下一级页表不存在，那就给它分配一页，创造新页表
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) { // create为1并且成功找到多的1个物理页才分配
            return NULL;
        }
        set_page_ref(page, 1);                          // 增加对物理页面page的引用数
        uintptr_t pa = page2pa(page);                   // page2pa 将一个页转换成这个页的物理地址
        memset(KADDR(pa), 0, PGSIZE);                   // 把物理地址pa映射到虚拟地址中，之后的一页内容全部置0
        // 不管页表怎么构造，我们确保物理地址和虚拟地址的偏移量始终相同，那么就可以用这种方式完成对物理内存的访问。
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
 ```
第一段是根据`la`前9位的索引，让`pdep1`指向`PTX1`顶级页表的第`PDX1(la)`项，如果该项不存在并且设置为可以被分配，那就分配一个物理页并且增加1次引用。
对于`page2pa`函数，在此一并分析。函数定义如下：
```C++
static inline ppn_t page2ppn(struct Page *page) { return page - pages + nbase; } 
// 页块数组中，页块的指针-页块数组的起始地址为页块编号，再把编号加上基准页数即为整个物理内存分页后的页编号
// 物理页码（PPN）只是一个数字，它表示页在物理内存中的索引或顺序位置。

static inline uintptr_t page2pa(struct Page *page) {
    return page2ppn(page) << PGSHIFT;
    // 物理页码左移12位后，就得到了以改页码
}
```
`page2pa`的功能是把页块结构体指针`page`映射到对应的物理页的起始地址上。其中调用了`page2ppn`这个函数。由于在Lab2中，在内核代码结束的内存空间里，我们用一个页块数组来存储从物理地址`0x80000000-0x88000000`的地址空间按照4KB分页后的页数。`pages`是该数组的起始地址，`page-pages`即为数组内的偏移，加上`nbase`即为对整个物理内存分页后的物理页码，左移12位号即为该页的起始物理地址。

继续分析`get_pte()`,`pa`中存储`page`页的物理地址，之后调用`memset()`将pa对应的虚拟地址上的一页内容全置为0，之后填入页表项内容（将物理地址和虚拟地址建立映射）。对于第二段，跟第一段的逻辑类似，来构造下一级页表`PDX0`的页表项，根据构造号的页表项再来索引第三级页表`PTX`，并最终返回`PTX`页表项的虚拟地址，在此不再赘述。

思考题：

 - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 
从上面的分析中可以看到，在 `get_pte()` 函数中，两段形式类似的代码实际上对应了 `sv39` 页表模式中的两级页表访问。第一段代码PDX1中，根据la的前9位索引导到页表项，访问或分配`PDX0`的页表项。在此过程中，如果页表项不存在，那么需要一个物理页面来存放下一级页表，所以需要分配一个物理页并将其映射到对应的物理地址上，最终把这个物理地址存到页表项中；第二段代码访问或分配了`PTX`的页表项，进行的操作类似。两段代码看起来相似，因为它们执行的是类似的操作，但在不同级别的页表上。因为是从顶级页表开始，`get_pte()` 只需处理两级，并向下查找直到找到或创建所需的页表项。这种模式是多级页表系统的一种常见模式，无论是采用二级页表的`sv32`、采用三级页表的`sv39`、还是采用四级页表的`sv48`，都遵循相似的逻辑，只是层数和索引方式有所不同。

 - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？
 
 我认为这种写法没问题，也没有必要将两个操作分开。理由如下：
 
 - 简化代码。只需要调用一个函数，使得代码更加简洁。同时find和alloc两个操作都需要对PDX0和PDX1进行索引，拆开写会使得代码冗余，还需要增加新的函数参数和返回值，不利于维护。
 - 保持一致性。不单独提供alloc的函数接口，将查找和分配页表项的操作原子化，避免在其他代码中错误地调用了分配的函数，减少错误。